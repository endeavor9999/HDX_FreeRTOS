/*
 * CAN.c
 *
 *  Created on: 2022. 11. 1.
 *      Author: USER
 */


/********************************************************************************************************************
 * \file MCMCAN.c
 * \copyright Copyright (C) Infineon Technologies AG 2020
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "Can.h"
#include "IfxPort.h"
#include "Bsp.h"

#include "Ifx_Types.h"
#include "IfxPort.h"


/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/

McmcanType                  Can_Device0;                       /* Global MCMCAN configuration and control structure    */
McmcanType                  Can_Device1;                       /* Global MCMCAN configuration and control structure    */
McmcanType                  Can_Device2;                       /* Global MCMCAN configuration and control structure    */
McmcanType                  Can_Device3;                       /* Global MCMCAN configuration and control structure    */

void Can_init(Can_Node_Info *Can_Info){

    uint8 currentFilterElement;

    IfxCan_Can_initModuleConfig(&Can_Info->Can_Ch->canConfig, Can_Info->Can_Module);
    IfxCan_Can_initModule(&Can_Info->Can_Ch->canModule, &Can_Info->Can_Ch->canConfig);
    IfxCan_Can_initNodeConfig(&Can_Info->Can_Ch->canNodeConfig, &Can_Info->Can_Ch->canModule);

    Can_Info->Can_Ch->canNodeConfig.messageRAM.baseAddress =(uint32)Can_Info->Can_Module;
    Can_Info->Can_Ch->canNodeConfig.nodeId = Can_Info->Node;

    Can_Info->Can_Ch->canNodeConfig.frame.type = IfxCan_FrameType_transmitAndReceive;
    //Can_Info->Can_Ch->canNodeConfig.frame.mode = IfxCan_FrameMode_fdLongAndFast;
    Can_Info->Can_Ch->canNodeConfig.frame.mode = IfxCan_FrameMode_standard;

   //Can_Info->Can_Ch->canNodeConfig.txConfig.txMode =IfxCan_TxMode_dedicatedBuffers; //IfxCan_TxMode_sharedFifo; // //IfxCan_TxMode_fifo;
   // Can_Info->Can_Ch->canNodeConfig.txConfig.txBufferDataFieldSize = IfxCan_DataFieldSize_64;
   // Can_Info->Can_Ch->canNodeConfig.txConfig.txFifoQueueSize = NUMBER_OF_FIFO_ELEMENTS;
   // Can_Info->Can_Ch->canNodeConfig.txConfig.txEventFifoSize = NUMBER_OF_FIFO_ELEMENTS;

    Can_Info->Can_Ch->canNodeConfig.interruptConfig.transmissionCompletedEnabled = TRUE;
    Can_Info->Can_Ch->canNodeConfig.interruptConfig.traco.priority = Can_Info->Tx_Priority;
    Can_Info->Can_Ch->canNodeConfig.interruptConfig.traco.interruptLine = Can_Info->Tx_InterruptLine;
    Can_Info->Can_Ch->canNodeConfig.interruptConfig.traco.typeOfService = IfxSrc_Tos_cpu0;
    Can_Info->Can_Ch->canNodeConfig.txConfig.dedicatedTxBuffersNumber=2;


    Can_Info->Can_Ch->canNodeConfig.rxConfig.rxMode = IfxCan_RxMode_sharedAll;
    //Can_Info->Can_Ch->canNodeConfig.rxConfig.rxBufferDataFieldSize = IfxCan_DataFieldSize_64;
    //Can_Info->Can_Ch->canNodeConfig.rxConfig.rxFifo0DataFieldSize = IfxCan_DataFieldSize_64;
    //Can_Info->Can_Ch->canNodeConfig.rxConfig.rxFifo1DataFieldSize = IfxCan_DataFieldSize_64;
    Can_Info->Can_Ch->canNodeConfig.rxConfig.rxBufferDataFieldSize = IfxCan_DataFieldSize_8;
    Can_Info->Can_Ch->canNodeConfig.rxConfig.rxFifo0DataFieldSize = IfxCan_DataFieldSize_8;
    Can_Info->Can_Ch->canNodeConfig.rxConfig.rxFifo1DataFieldSize = IfxCan_DataFieldSize_8;
    Can_Info->Can_Ch->canNodeConfig.rxConfig.rxFifo0Size = NUMBER_OF_FIFO_ELEMENTS;
    Can_Info->Can_Ch->canNodeConfig.rxConfig.rxFifo1Size = NUMBER_OF_FIFO_ELEMENTS;

    Can_Info->Can_Ch->canNodeConfig.filterConfig.messageIdLength = IfxCan_MessageIdLength_both;
    Can_Info->Can_Ch->canNodeConfig.filterConfig.standardListSize = NUMBER_OF_STND_ID_FILTERS;
    Can_Info->Can_Ch->canNodeConfig.filterConfig.extendedListSize = NUMBER_OF_EXTD_ID_FILTERS;
    Can_Info->Can_Ch->canNodeConfig.filterConfig.standardFilterForNonMatchingFrames = IfxCan_NonMatchingFrame_acceptToRxFifo1;
    Can_Info->Can_Ch->canNodeConfig.filterConfig.extendedFilterForNonMatchingFrames = IfxCan_NonMatchingFrame_reject;
    Can_Info->Can_Ch->canNodeConfig.filterConfig.rejectRemoteFramesWithStandardId = TRUE;
    Can_Info->Can_Ch->canNodeConfig.filterConfig.rejectRemoteFramesWithExtendedId = TRUE;


    ///RX INTERRUPT//////
    Can_Info->Can_Ch->canNodeConfig.interruptConfig.messageStoredToDedicatedRxBufferEnabled = TRUE;
    Can_Info->Can_Ch->canNodeConfig.interruptConfig.reint.priority = Can_Info->Rx_Priority[0];
    Can_Info->Can_Ch->canNodeConfig.interruptConfig.reint.interruptLine = Can_Info->Rx_InterruptLine[0];
    Can_Info->Can_Ch->canNodeConfig.interruptConfig.reint.typeOfService = IfxSrc_Tos_cpu0;

    Can_Info->Can_Ch->canNodeConfig.interruptConfig.rxFifo0NewMessageEnabled = TRUE;
    Can_Info->Can_Ch->canNodeConfig.interruptConfig.rxf0n.priority = Can_Info->Rx_Priority[1];
    Can_Info->Can_Ch->canNodeConfig.interruptConfig.rxf0n.interruptLine = Can_Info->Rx_InterruptLine[1];
    Can_Info->Can_Ch->canNodeConfig.interruptConfig.rxf0n.typeOfService = IfxSrc_Tos_cpu0;

    Can_Info->Can_Ch->canNodeConfig.interruptConfig.rxFifo1NewMessageEnabled = TRUE;
    Can_Info->Can_Ch->canNodeConfig.interruptConfig.rxf1n.priority = Can_Info->Rx_Priority[2];
    Can_Info->Can_Ch->canNodeConfig.interruptConfig.rxf1n.interruptLine = Can_Info->Rx_InterruptLine[2];
    Can_Info->Can_Ch->canNodeConfig.interruptConfig.rxf1n.typeOfService = IfxSrc_Tos_cpu0;

    Can_Info->Can_Ch->canNodeConfig.pins = &Can_Info->pins;

    IfxCan_Can_initNode(&Can_Info->Can_Ch->canSrcNode, &Can_Info->Can_Ch->canNodeConfig);

    for(currentFilterElement = 0; currentFilterElement < Can_Info->Filter_Std_Num; currentFilterElement++)
    {
        IfxCan_Can_setStandardFilter(&Can_Info->Can_Ch->canSrcNode, &Can_Info->Filter_Std_Cfg[currentFilterElement]);
    }
    for(currentFilterElement = 0; currentFilterElement < Can_Info->Filter_Ext_Num; currentFilterElement++)
    {
        IfxCan_Can_setExtendedFilter(&Can_Info->Can_Ch->canSrcNode, &Can_Info->Filter_Ext_Cfg[currentFilterElement]);
    }


}
