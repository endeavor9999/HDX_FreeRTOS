/**********************************************************************************************************************
 * \file Cpu0_Main.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/
#include "Ifx_Types.h"
#include "IfxCpu.h"
#include "IfxScuWdt.h"
#include "ASCLIN_Shell_UART.h"
#include "User_RTOS.h"
#include "PORT_cfg.h"
#include "GPT12_Timer_Interrupt.h"

#include "PWR_SQ.h"
#include "Can_Cfg.h"
#include "Ifx_Console.h"                                                                            //Function   Mode   Direction  Latch  Pull Up Pull Down Drive Strength

IFX_ALIGN(4) IfxCpu_syncEvent g_cpuSyncEvent = 0;

void main_loop(void *arg);
void Pwr_SQgpio(void *arg);

uint32 sda=0;

// 보드에 맞게 조정하세요
#define CAN0_TX_PORT   PORT02
#define CAN0_TX_PIN    PIN_00   // P02.0 = CAN0_TXD
#define CAN0_RX_PORT   PORT02
#define CAN0_RX_PIN    PIN_01   // P02.1 = CAN0_RXD
#define CAN0_STB_PORT  PORT02
#define CAN0_STB_PIN   PIN_02   // P02.2 = CAN0_STB

#define CAN1_TX_PORT   PORT02
#define CAN1_TX_PIN    PIN_09   // P02.0 = CAN0_TXD
#define CAN1_RX_PORT   PORT02
#define CAN1_RX_PIN    PIN_10   // P02.1 = CAN0_RXD
#define CAN1_STB_PORT  PORT02
#define CAN1_STB_PIN   PIN_11   // P02.2 = CAN0_STB

#define CAN2_TX_PORT   PORT00
#define CAN2_TX_PIN    PIN_00   // P02.0 = CAN0_TXD
#define CAN2_RX_PORT   PORT00
#define CAN2_RX_PIN    PIN_01   // P02.1 = CAN0_RXD
#define CAN2_STB_PORT  PORT00
#define CAN2_STB_PIN   PIN_02   // P02.2 = CAN0_STB



void core0_main(void)
{
    IfxCpu_enableInterrupts();
    
    /* !!WATCHDOG0 AND SAFETY WATCHDOG ARE DISABLED HERE!!
     * Enable the watchdogs and service them periodically if it is required
     */
    IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());
    IfxScuWdt_disableSafetyWatchdog(IfxScuWdt_getSafetyWatchdogPassword());
    
    /* Wait for CPU sync event */
    IfxCpu_emitEvent(&g_cpuSyncEvent);
    IfxCpu_waitEvent(&g_cpuSyncEvent, 1);
    Port_Init();
    initGpt12Timer();

    initShellInterface();




    sys_thread_new("task_app_PWR_SQ",task_app_PWR_SQ,NULL,configMINIMAL_STACK_SIZE,4);
    xTaskCreate(main_loop, "main_loop", configMINIMAL_STACK_SIZE, NULL, 6, NULL);
    //sys_thread_new("Pwr_SQgpio",Pwr_SQgpio,NULL,512,4);
    //sys_thread_new("main_loop",main_loop,NULL,1024,4);
    vTaskStartScheduler();

    while(1)
    {
        sda++;

    }
}
extern uint32 g_can0_rx_cnt;
extern uint32 g_can1_rx_cnt;
extern uint32 g_can2_rx_cnt;
uint32 str;
void main_loop(void *arg)
{
    TickType_t lastCanTick0 = xTaskGetTickCount();
    TickType_t lastCanTick1 = xTaskGetTickCount();
    TickType_t lastCanTick2 = xTaskGetTickCount();

    uint32 lastRxMarker = 0;
    uint32 lastRxCnt0 = 0;
    uint32 lastRxCnt1 = 0;
    uint32 lastRxCnt2 = 0;

    //CAN0 STB LOW
    IfxPort_setPinPadDriver(CAN0_STB_PORT, CAN0_STB_PIN, IfxPort_PadDriver_cmosAutomotiveSpeed1);
    IfxPort_setPinModeOutput(CAN0_STB_PORT, CAN0_STB_PIN,IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    IfxPort_setPinLow(CAN0_STB_PORT, CAN0_STB_PIN);
    IfxPort_setPinPadDriver(CAN0_TX_PORT, CAN0_TX_PIN, IfxPort_PadDriver_cmosAutomotiveSpeed1);
    IfxPort_setPinModeOutput(CAN0_TX_PORT, CAN0_TX_PIN, IfxPort_OutputMode_pushPull,IfxPort_OutputIdx_alt2);
    IfxPort_setPinModeInput(CAN0_RX_PORT, CAN0_RX_PIN, IfxPort_InputMode_noPullDevice);

    //CAN1 STB LOW
    IfxPort_setPinPadDriver(CAN1_STB_PORT, CAN1_STB_PIN, IfxPort_PadDriver_cmosAutomotiveSpeed1);
    IfxPort_setPinModeOutput(CAN1_STB_PORT, CAN1_STB_PIN,IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    IfxPort_setPinLow(CAN1_STB_PORT, CAN1_STB_PIN);
    IfxPort_setPinPadDriver(CAN1_TX_PORT, CAN1_TX_PIN, IfxPort_PadDriver_cmosAutomotiveSpeed1);
    IfxPort_setPinModeOutput(CAN1_TX_PORT, CAN1_TX_PIN, IfxPort_OutputMode_pushPull,IfxPort_OutputIdx_alt2);
    IfxPort_setPinModeInput(CAN1_RX_PORT, CAN1_RX_PIN, IfxPort_InputMode_noPullDevice);

    //CAN2 STB LOW
    IfxPort_setPinPadDriver(CAN2_STB_PORT, CAN2_STB_PIN, IfxPort_PadDriver_cmosAutomotiveSpeed1);
    IfxPort_setPinModeOutput(CAN2_STB_PORT, CAN2_STB_PIN,IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    IfxPort_setPinLow(CAN2_STB_PORT, CAN2_STB_PIN);
    IfxPort_setPinPadDriver(CAN2_TX_PORT, CAN2_TX_PIN, IfxPort_PadDriver_cmosAutomotiveSpeed1);
    IfxPort_setPinModeOutput(CAN2_TX_PORT, CAN2_TX_PIN, IfxPort_OutputMode_pushPull,IfxPort_OutputIdx_alt2);
    IfxPort_setPinModeInput(CAN2_RX_PORT, CAN2_RX_PIN, IfxPort_InputMode_noPullDevice);


    ////////////////////
    Can_NodeConfig_Set();
    Can_init(&Can0_Cfg);
    Can_init(&Can1_Cfg);
    Can_init(&Can2_Cfg);

    while(1)
    {
        str++;
        runShellInterface(); /* Run the application shell */


       //*
        if((xTaskGetTickCount() - lastCanTick0) >= pdMS_TO_TICKS(1000))
        {
            Can0_Cfg.Can_Ch->txMsg.messageId = 0x201;
            Can0_Cfg.Can_Ch->txMsg.dataLengthCode = IfxCan_DataLengthCode_8;
            Can0_Cfg.Can_Ch->txMsg.frameMode = IfxCan_FrameMode_standard;
            Can0_Cfg.Can_Ch->txData[0] = 0x01010101U;
            Can0_Cfg.Can_Ch->txData[1] = 0x01010101U;
            IfxCan_Can_sendMessage(&Can0_Cfg.Can_Ch->canSrcNode, &Can0_Cfg.Can_Ch->txMsg,
                                   &Can0_Cfg.Can_Ch->txData[0]);
            lastCanTick0 = xTaskGetTickCount();
            Ifx_Console_print("TEST SEND0\r\n");
        }
        if (lastRxCnt0 != g_can0_rx_cnt)
        {
            lastRxCnt0 = g_can0_rx_cnt;
            Ifx_Console_print("TEST0 \r\n");
            lastRxMarker = Recive_Data_0x201[0][0];
            Ifx_Console_print("CAN RX 0x201: %08X %08X (cnt=%u)\r\n",
                              Recive_Data_0x201[0][0], Recive_Data_0x201[0][1],lastRxCnt0);
        }
        // */
        //*
        if((xTaskGetTickCount() - lastCanTick1) >= pdMS_TO_TICKS(1000))
        {
            Can1_Cfg.Can_Ch->txMsg.messageId = 0x202;
            Can1_Cfg.Can_Ch->txMsg.dataLengthCode = IfxCan_DataLengthCode_8;
            Can1_Cfg.Can_Ch->txMsg.frameMode = IfxCan_FrameMode_standard;
            Can1_Cfg.Can_Ch->txData[0] = 0x01010101U;
            Can1_Cfg.Can_Ch->txData[1] = 0x01010101U;
            IfxCan_Can_sendMessage(&Can1_Cfg.Can_Ch->canSrcNode, &Can1_Cfg.Can_Ch->txMsg,
                                   &Can1_Cfg.Can_Ch->txData[0]);
            lastCanTick1 = xTaskGetTickCount();
            Ifx_Console_print("TEST SEND1\r\n");
        }
        if (lastRxCnt1 != g_can1_rx_cnt)
        {
            lastRxCnt1 = g_can1_rx_cnt;
            Ifx_Console_print("TEST1 \r\n");
            lastRxMarker = Recive_Data_0x201[0][0];
            Ifx_Console_print("CAN RX 0x201: %08X %08X (cnt=%u)\r\n",
                              Recive_Data_0x201[1][0], Recive_Data_0x201[1][1],lastRxCnt1);
        }
        // */
        //*
        if((xTaskGetTickCount() - lastCanTick2) >= pdMS_TO_TICKS(1000))
        {
            Can2_Cfg.Can_Ch->txMsg.messageId = 0x203;
            Can2_Cfg.Can_Ch->txMsg.dataLengthCode = IfxCan_DataLengthCode_8;
            Can2_Cfg.Can_Ch->txMsg.frameMode = IfxCan_FrameMode_standard;
            Can2_Cfg.Can_Ch->txData[0] = 0x01010101U;
            Can2_Cfg.Can_Ch->txData[1] = 0x01010101U;
            IfxCan_Can_sendMessage(&Can2_Cfg.Can_Ch->canSrcNode, &Can2_Cfg.Can_Ch->txMsg,
                                   &Can2_Cfg.Can_Ch->txData[0]);
            lastCanTick2 = xTaskGetTickCount();
            Ifx_Console_print("TEST SEND2\r\n");
        }
        if (lastRxCnt2 != g_can2_rx_cnt)
        {
            lastRxCnt2 = g_can2_rx_cnt;
            Ifx_Console_print("TEST2 \r\n");
            lastRxMarker = Recive_Data_0x201[0][0];
            Ifx_Console_print("CAN RX 0x201: %08X %08X (cnt=%u)\r\n",
                              Recive_Data_0x201[2][0], Recive_Data_0x201[2][1],lastRxCnt2);
        }
        // */
        //Ifx_Console_print("TEST \r\n");
        //vTaskDelay(100);
        vTaskDelay(pdMS_TO_TICKS(10));
    }
}

